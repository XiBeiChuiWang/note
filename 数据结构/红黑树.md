# 红黑树

### 定义

1. 每个节点都有红色或黑色
2. 树的根始终是黑色的
3. 没有两个相邻的红色节点（红色节点不能有红色父节点或红色子节点，并没有说不能出现连续的黑色节点）
4. 从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点



前一节说过，红黑树和4阶B树（2-3-4树）很像那么二者怎么转化呢

![](https://img.imgdb.cn/item/5ffaf4cf3ffa7d37b37ac578.png)



### 添加操作

重头戏要来了，红黑树的添加操作一共有12种情况（！！！！！）

那么这12种情况长什么样子呢



![](https://img.imgdb.cn/item/5ffaf6a73ffa7d37b37be6b3.png)

1. 首先我们先看7和8

   这种情况称为LL和RR，例如7，只要把50变黑46变红就可以了（在红黑树中先对46进行左旋转）

   8的话同理

2. 6和9

   LR和RL，例如6，先将50右旋，再将46左旋，将48变黑，46变红

3. 1 2 3 4

   特点是uncle节点为红色（B树的上溢）

   步骤为：

   1. parent uncle染成black
   2. grand向上合并（染成红色，当作新添加的节点处理，有可能继续上溢直到根节点）

4. 如果父节点为黑色 5 10 11 12

   直接添加，无需改变。 

​	

### 删除操作

![](https://img.imgdb.cn/item/5ffbc6ce3ffa7d37b3db8f31.png)

1. 删除拥有一个red节点的black节点（ 46 76）

   找到替代节点删除，再染黑

2. 如果被最终被删除的节点是红色（替代节点也包含在内）直接删除

3. 如果为根节点，直接删除

4. 如果为black叶子节点（88）会出现B树下溢

   先看兄弟节点是否可以借他节点（兄弟节点必须是黑色才可以借）

   如果可以例如88 删掉88，直接右旋80将72 80 染黑将76染红

   如果兄弟比较穷，不能借的话那就B树下溢

   ![](https://img.imgdb.cn/item/5ffbcda83ffa7d37b3dec153.png)

5. 接4 如果兄弟节点为red可以将兄弟节点染黑父节点染红然后进行旋转

   ![](https://img.imgdb.cn/item/5ffbcd373ffa7d37b3de4eca.png)

OK，到这里红黑树的基本操作就讲完了，是不是感觉很麻烦，感觉没有AVL树那么清晰明了

那么在具体的使用中，我们应该用红黑树还是AVL树呢

我们看下他们的对比

|   树   |                    平衡标准                     | 复杂度                                                       |           使用地点           |
| :----: | :---------------------------------------------: | ------------------------------------------------------------ | :--------------------------: |
| AVL树  |       非常严格，每个左右子树高度差最多为1       | 添加 搜索 删除：O（logn）<br />其中添加最多需要O(1)次旋转操作<br />删除最多需要O(logn)次旋转操作 | 当搜索次数远远大于插入和删除 |
| 红黑树 | 相对比较宽松，没有一条的路径会大于其他路径的2倍 | 添加 搜索 删除：O（logn）<br />添加和删除最多需要O(1)次旋转操作 |           一般条件           |

看这个是不是一目了然呢，碍于篇幅，红黑树代码将在下一篇给出。