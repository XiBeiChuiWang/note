# HashMap

HashMap是java中很常用的一个集合，想必大家或多或少的都听过他的大名，那么他究竟是怎么实现的呢，一起来看看吧。

首先我们可以很确定的是，他的底层存储用的是Node（键值对嘛）

我们来看看他的基本结构长什么样子

*注：以下不特殊说明，都是基于jdk8.0及以上*

![](https://img.imgdb.cn/item/600430c83ffa7d37b39de38b.jpg)

哎呀，这是个什么玩意儿？

不要急这东西呢，叫哈希表（也叫散列表），是基于hash函数的。

>  Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
>
> [ 具体详见](https://baike.baidu.com/item/Hash/390310?fromtitle=hash%E5%87%BD%E6%95%B0&fromid=10555888&fr=aladdin)

首先可以看到他是有一个table数组，存储的是链表的首节点或者是树的根节点，有些同学可能比较疑惑，或？那到底是什么，我们看一下hashmap的规则：初始化后首先使用链表，在某一条链表长度超过8之后，变为红黑树存储。

### 初始化

```text
 	 int threshold;             // 所能容纳的key-value对极限 
     final float loadFactor;    // 负载因子
     int modCount;  
     int size;
```

**首先，Node[] table的初始化长度length(默认值是16)**

**Load factor为负载因子(默认值是0.75)**

**threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。**

**也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。** 

 **threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。**

**默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。** 

### 功能方法

1. ##### 确定table表的索引

   ![](https://img.imgdb.cn/item/600436143ffa7d37b3a085a2.jpg)

2. ##### put方法

   ![](https://img.imgdb.cn/item/600436143ffa7d37b3a085b9.jpg)

   ①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；

   ②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；

   ③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；

   ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；

   ⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；

   ⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。

3. ##### 扩容操作

   **在扩容后，每个节点该往那个索引放不需要重新计算因为只要在左边多一位就行。  只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap” 。由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了** 。

   

#### jdk7和8的区别

1. 数组+链表改成了数组+链表或红黑树；
2. 链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7将新元素放到数组中，原始节点作为新节点的后继节点，1.8遍历链表，将元素放置到链表的最后；
3. 扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；
4. 在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；

#### 线程安全性

 **在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。** 