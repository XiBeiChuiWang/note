# 索引

1. ### 索引的概念

   索引就是一种数据结构，它可以帮助我们在海量数据中很快的查找到我们需要的数据。

2. ### 索引的分类

   索引有很多种，和算法一样，没有最好的索引，只有最合适的索引。在我们MySql中索引是由我们的存储引擎实现的，这就导致各个不同的存储引擎中索引的工作方式也不尽相同，我们来看看MySql中的索引吧。

   - #### B-Tree索引

     一提到这个名字，了解过B树的同学们肯定不会陌生了，但是要注意**B-Tree != B树**，在不同的存储引擎中，即使他们都支持B-Tree，但是却不是一个东西，例如，InnoDB是使用的B+树，而NDB使用的是T-Tree等，不尽相同，但是其大致思想是相同的。

     B-Tree意味着所有的值是排好序的，而且每一个叶子页到根的距离相同，我们就以InnoDb引擎来说。

     ![](https://pic.imgdb.cn/item/603b4cfa5f4313ce25a09236.jpg)

     可以看到这就是B+树，大家可以认为key就是索引字段，而value就是行数据的地址值（聚簇索引例外）

     我们来举一个例子，例如有一张user表，这张表有4个字段（姓，名，年龄，性别），我们既可以使用单列索引，还可以建立复合索引，如果我们建立了一个（姓，名，年龄）索引，那么他排序会首先根据姓来排，如果姓重合了，才会使用名，以此类推

     - ##### 优点：

       因为他是顺序存储，因此特别适合范围查找

       数据是排好序的，不需要额外排序（前提是排序字段与索引字段一致）

     - ##### 查询有效

       既然我们建好了索引，那在什么样的条件下他才会其作用呢？

       - **全值匹配**

         例如我们查找叫做张三，年龄为18岁的人

       - **匹配最左前缀**

         例如我们查找姓张的人

       - **匹配列前缀**

         例如有复姓（诸葛），我们匹配姓开头为诸的人

       - **匹配范围值**

         例如我们找姓（李 --- 张）的人（按照拼音首字母排序）

       - **精确匹配某一列，并范围匹配另一列**

         例如我们查找姓李的，且名字以狗开头的人（李狗蛋等）

     - 限制

       既然上述情况下可以使用，那么在什么情况下不可以呢

       - 我们查找名字叫做狗剩的就不可以
       - 不能跳过列，如果我们查找姓张年龄为18的，就不能使用年龄为18的，MySql只能使用第一列
       - 如果有一列使用范围查找，那他右边的列的索引就会失效，例如我们查找姓张，名字叫做 狗% ，年龄为18的，年龄这一列的索引就会失效。

       到了这里大家应该明白，创建索引时，**列的顺序**有多重要了吧。

   - #### 哈希索引

     hash索引跟我们学过的散列表很相似，都是基于hash算法的，但是在MySql中，只有Memory显示支持hash索引。

     假设我们还是上述那张表，我们在他的name字段添加一个hash索引（假设hash算法采用 f() ），会是什么情况呢

     首先他会算出表中每一条数据的name值的hash值

     例如：

     | name | f（name） |  行  |
     | :--- | :-------- | :--: |
     | 三   | 1244      |  1   |
     | 四   | 2567      |  2   |
     | 五   | 1425      |  3   |

     

     那这个hash索引的数据结构为

     | 槽（slot） | value |
     | :--------: | :---: |
     |    1244    |   1   |
     |    2567    |   2   |
     |    1425    |   3   |

     我们查询叫做四的人，第一步我们算出f（四） = 2567，然后直接去表中查找2567这个槽保存的数据，这个值指向我们第二行，最后我们查看第二行数据的名是否为四。（最后一步是为了防止hash冲突）

     - 优点

       由于其索引结构很小（只需要存储hash值及指针），因此其速度非常快。

     - 限制

       说完优点，该说缺点了

       - 首先，因为他的索引只存储这么点数据，因此我们每次查询出来都得去具体的行去查看真正的数据，不存在所谓的覆盖索引
       - 无法用该索引进行排序
       - 如果对姓和名建立hash索引，那么单单查询姓是不可以使用该索引的
       - 只支持等值查询，不支持范围查询
       - 会出现hash冲突，如果冲突很多的话，维护hash表也是一件很恐怖的事情

     由于这些缺点，hash索引只用在某些特定的场合，而一旦适合hash索引，那他的性能提升将会非常明显。

     看完这个，那么真的只有Memory支持hash索引吗？

     我们的InnoDb引擎有一个**自适应hash索引功能**，如果引擎发现一张表的某些索引值被使用的很频繁，那么就会在B-Tree上建立一个伪hash索引，我们来看看怎么实现

     例如我们要存储url（很长），如果直接用url建立索引，那还是比较慢的，我们就可以在该表上新增一个hash_url列，然后自定义一种hash算法，将url作为参数，输出结果保存在hash_url列，然后对hash_ur新增一个索引。

     查询的时候，我们只需要select * from 表 where url = "url" and hash_url = f(url)，这样做我们的性能提升会非常巨大。

   - #### 空间数据索引（R-Tree）

     和B-Tree不同，无需使用前缀进行查询，查询时可使用任意维度进行组合查询，Mysql对此不太完善，因此大部分人不会选择

   - #### 全文索引

     特殊类型的索引，和其他索引的匹配方式完全不同（后面再讲）

   现在我们再来看看索引的优点

   1. 索引减少了I/O量
   2. 不需要排序
   3. 可将随机I/O变为顺序I/O

   