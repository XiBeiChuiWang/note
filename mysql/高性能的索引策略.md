# 高性能的索引策略

1. ### 单列索引

   单列索引需要注意需要在where中把索引列单独放在符号的一侧。

2. ### 前缀索引和索引选择性

   如果要向BLOB，TEXT或者很长的VARCHAR添加索引怎么办，我们总不能全加进去吧。

   这个时候我们就引出前缀索引，只索引开始的部分字符，那这个字符长度咱们该设置多长呢？

   太短的话，不起作用，大家都是一样的，还得一个一个扫描。

   太长的话，又太浪费空间，修改表的时候花销又太大。

   最好的做法就是我们引出一个**索引选择性**的概念，简单来说，就是表中某一个字段值的种类/总行数

   还是上一篇那个例子（姓，名，年龄，性别）例如姓的选择性的值就是表中一共有多少个姓/总行数，通过这个原理，我们就可以算出不同前缀长度的选择性大小，然后进行取舍。

3. ### 多列索引

   首先，为每个列都创建独立的索引是错误的。

   MySql5.0之后引入了一种**索引合并**的策略，但是并不代表我们可以去肆无忌惮的创建索引，因为这种策略是很浪费性能的，如果频繁出现了索引合并，我们就应该审视一下我们的索引，看他是不是很糟糕。

4. ### 选择合适的索引列顺序

   在我们不需要排序或者分组的时候，我们只需要把**选择性最强**的列放到前面，当然这也不是绝对的，具体情况具体分析

5. ### 聚簇索引

   **聚簇索引不是一种单独的索引类型，他只是一种数据结构。**

   聚簇的意思表示数据行和相邻的键值紧紧的连在一起，因为无法将数据行放在两个地方，因此**一个表中只能有一个聚簇索引**。

   InnoDB会选择主键来聚集数据，我们来看一张表

   其中c1是主键，c2上也有一个索引

   | 行号   | c1     | c2     |
   | ------ | ------ | ------ |
   | 0      | 99     | 8      |
   | 1      | 12     | 56     |
   | 2      | 3000   | 62     |
   | ...... | ...... | ...... |
   | 9997   | 18     | 8      |
   | 9998   | 4700   | 13     |
   | 9999   | 3      | 93     |

   如果我们就按这张表中的顺序来添加数据

   - ##### MYISAM引擎：

     **主键索引：**

     ![](https://pic.imgdb.cn/item/603b94145f4313ce25d48340.jpg)

     叶子节点存储的是主键列以及行地址

     **c2索引：**

     ![](https://pic.imgdb.cn/item/603b94b15f4313ce25d4f57f.jpg)

     叶子节点存储的是c2列以及行地址

     我们的数据还是存在上面那张表里

   - **InnoDB引擎：**

     首先大家忘掉那张表，在InnoDB中，他并不存在，我们只需要他的插入顺序

     ![](https://pic.imgdb.cn/item/603b95985f4313ce25d5a771.jpg)

     叶子节点存储的是**整张表**

     ![](https://pic.imgdb.cn/item/603b96675f4313ce25d64683.jpg)

     叶子节点存储的是c2列以及主键值

     到这里有些同学困惑了，为什么不直接存储行内地址呢，因为如果行内地址发生了变化的话，我们还得修改其他索引，但是使用这种方式的话我们如果使用非主键索引的话，先拿到主键值，然后还得走一遍主键索引

     - 优点
       1. 我们把相关的数据聚集在一起，只需要访问比较少的页就可以拿到我们想要的所有数据
       2. 数据访问更快，因为索引与数据保存在同一棵B-Tree中
     - 缺点
       1. 插入速度严重依赖于插入顺序，如果顺序杂乱无章，完蛋
       2. 更新聚簇索引列代价很高
       3. 可能会面临页分裂问题，产生内存碎片
       4. 可能导致全表扫描变慢（因为页分裂）
       5. 二级索引比想像的大（二级索引保存主键值）
       6. 二级索引访问需要两次索引查找（一次二级索引，一次主键索引）

   - 我们来使用两张图总结一下

     - ##### 聚簇索引

       ![](https://pic.imgdb.cn/item/603b9ad35f4313ce25d97aef.jpg)

     - ##### 非聚簇索引

       ![](https://pic.imgdb.cn/item/603b9fa55f4313ce25dcbe29.jpg)

6. ### 覆盖索引

   如果一个索引包含（覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”

   好处：

   1. 只需要读取索引，MySql会极大的减少数据访问量。
   2. 一些存储引擎在内存中只缓存索引，速度很快。
   3. 由于聚簇索引，覆盖索引对InnoDB表特别有用，可以避免InnoDB二次查询。

   例如我们有一张表user（id,name,age,sex），有一个复合索引（name,age）

   我们来看select * from user where age= 18  and name like "%三"

   不能使用覆盖索引，原因有二：

   - 第一点大家很容易就能看出来，*，索引中不能覆盖所有的字段，因此不能使用。
   - 第二点，问题出在like中，MySql中只允许在索引中使用较简单的基本比较，以通配符开头的like操作是不能使用的，只能使用最左前缀匹配的like

7. ### 使用索引来排序

   排序所需要的字段需要和索引字段的顺序完全相同，如果是多表查询的话，就需要order by后面引用的字段全部属于第一个表。

   但是也有例外，可以违反最左前缀的要求，还是上面的例子，如果语句为

   select * from user where name = "狗剩" order by age

   这是可以借用索引实现排序的

8. ### 压缩索引

   MyISAM使用前缀压缩来节省空间，使得其可让更多的索引放在内存中，在某种情况下，我们可以极大的提升性能，默认只压缩字符串，但是通过参数也可以压缩整数。

   压缩过程，例如首个字符串为name，第二个字符串为namespace，压缩后就为4，space以此来节省空间，但是代价是，每次只能从前往后找，因为必须找到第一个字符串，查找操作平均需要查找半个索引块。

9. ### 冗余和重复索引

   重复索引很简单，就是一模一样的索引，我们应该避免这种情况发生

   冗余索引，就是比如我们建立了（name，age）又建立了（name），这就是冗余索引，但在部分条件下是有用的（例如排序）

10. ### 索引和锁

    索引可以让查询锁定更少的行，设想如果没有使用索引去查找，MySql会做全表扫描并且会锁住所有的行，这是很恐怖的。

    另外，在InnoDB中，二级索引采用的共享锁，主键索引采用的排他锁。