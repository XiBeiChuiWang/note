# ElasticSearch

## ElasticSearch概述

Elasticsearch（简称ES）是一个基于开源切高扩展的分布式全文检索引擎，它可以近乎实时的储存、检索数据；因本身扩展性很好、可以扩展到上百台服务器、处理PB级数据

Elasticsearch 是一个分布式、高扩展、高实时的搜索与[数据分析](https://baike.baidu.com/item/数据分析/6577123)引擎。它能很方便的使大量数据具有搜索、分析和探索的能力。充分利用Elasticsearch的水平伸缩性，能使数据在生产环境变得更有价值。Elasticsearch 的实现原理主要分为以下几个步骤，首先用户将数据提交到Elasticsearch 数据库中，再通过分词控制器去将对应的语句分词，将其权重和分词结果一并存入数据，当用户搜索数据时候，再根据权重将结果排名，打分，再将返回结果呈现给用户。

Elasticsearch是与名为Logstash的数据收集和日志解析引擎以及名为Kibana的分析和可视化平台一起开发的。这三个产品被设计成一个集成解决方案，称为“Elastic Stack”（以前称为“ELKstack”）。

Elasticsearch可以用于搜索各种文档。它提供可扩展的搜索，具有接近实时的搜索，并支持多租户。”Elasticsearch是分布式的，这意味着索引可以被分成分片，每个分片可以有0个或多个副本。每个节点托管一个或多个分片，并充当协调器将操作委托给正确的分片。再平衡和路由是自动完成的。“相关数据通常存储在同一个索引中，该索引由一个或多个主分片和零个或多个复制分片组成。一旦创建了索引，就不能更改主分片的数量。

Elasticsearch使用Lucene，并试图通过JSON和Java API提供其所有特性。它支持facetting和percolating，如果新文档与注册查询匹配，这对于通知非常有用。另一个特性称为“网关”，处理索引的长期持久性；例如，在服务器崩溃的情况下，可以从网关恢复索引。Elasticsearch支持实时GET请求，适合作为NoSQL数据存储，但缺少分布式事务。

## ES核心概念

**elasticsearch是面向文档,一切都是JSON**

### 索引

就是数据库！

索引是腴射类型的容器, elasticsearch中的索引是一个非常大的文档集合,索引存储了映射类型的字段和其他设置。然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的

### 字段类型

类型是文档的逻輯容器,就像关系型数据库一样,表格是行的容器。类型中对于字段的定义称为映射,比如ηame映射为字符串类型。我们说文档是无模式的,它们不需要拥有映射中所定义的所有字段,比如新增一个字段,那么 elasticsearch是怎么做的呢?
elasticsearch会自动的将新字段加入映射,但是这个字段的不确定它是什么类型, elasticsearch就开始猜,如果这个值是18,那么elasticsearch会认为它是整形,但是 elasticsearch也可能猜不对,所以最安全的方式就是提前定义好所需要的映射,这点跟关系型数据库殊途同归了,先定义好字段,然后再使用,别整什么幺蛾子

### 文档

文档 (就类似于MySQL中一个表的一条条数据)

之前说elasticsearch是面向文档的，那么意味着索引和搜索数据的最小单位是文档，elasticsearch中，文档有几个重要属性：

- 自我包含,一篇文档同时包含字段和对应的值,也就是同时包含key，value!
- 可以是层次型的,一个文档中包含自文档,复杂的逻辑实体就是这么来的!（就是一个JSON对象，FastJson进行转换!）
- 灵活的结构,文档不依赖预先定义的模式,我们知道关系型数据库中,要提前定义字段才能使用,在elasticsearch中,对于字段是非常灵活的,有时候,我们可以忽略该字段,或者动态的添加一个新的字段。

尽管我们可以随意的新增或者忽略某个字段,但是,每个字段的类型非常重要,比如一个年龄字段类型,可以是字符串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置,这种映射具体到每个映射的每种类型,这也是为什么在elasticsearch中,类型有时候也称为映射类型。

一个类型中,包含多个文档,比如说文档1,文档2,当我们索引一篇文档时,可以通过这样的一名顺序找到它:**索引>类型>文档ID**,通过这个组合我们就能索引到某个具体的文档。注意:ID不必是整数,实际上它是个字符串。

## ES为什么这么快？

ES内部使用了**倒排索引**（反向索引）

### 正向索引

我们来看三段文档：

| 行号 |      文档内容      |
| :--: | :----------------: |
|  1   |   郑小熊太可爱了   |
|  2   | 郑小熊一点都不可爱 |
|  3   |     郑小熊真棒     |

正向索引就是在每一个文档上面都建立一个关键词列表

| 行号 |                        索引内容                        |
| :--: | :----------------------------------------------------: |
|  1   |   （郑小熊：1），（太：1），（可爱：1），（了，：1）   |
|  2   | （郑小熊：1），（一点：1），（都不，：1），（可爱：1） |
|  3   |          （郑小熊：1），（真：1），（棒：1）           |

我们不难看出问题，如果使用这种索引搜索海量数据时不仅占用空间，而且速度很慢。

### 倒排索引

还是上面的文档

| 关键字/词 |    索引内容（行号：次数）    |
| :-------: | :--------------------------: |
|  郑小熊   | （1：1），（2：1），（3：1） |
|    太     |            ......            |
|   可爱    |            ......            |
|    了     |            ......            |
|   一点    |            ......            |
|   都不    |            ......            |
|    真     |            ......            |
|    棒     |            ......            |

这样的话我们可以发现占用空间要小很多，那么怎样快速定位关键字呢

- 哈希法
- B树

（不赘述了）

## 索引的基本操作

### 创建索引

```json
PUT  /索引名/~类型名~/文档id
{
    请求体
}
```

### 类型

- 字符串

  text、keyword

- 数值类型

  long、integer、short、byte、dubble、float、half float、scaled float

- 日期类型

  date

- te布尔值类型

  boolean

- 二进制类型

  binary

- ……

![](https://pic.imgdb.cn/item/60a3d3fb6ae4f77d3565f588.png)

