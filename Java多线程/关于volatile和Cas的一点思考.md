# 关于volatile和Cas的一点思考

我们知道volatile的两个作用：保证可见性以及禁止指令重排。

我们今天就先来探讨一下可见性

## 可见性

提到可见性，我们就不得不提JMM（java内存模型）

![](https://pic.imgdb.cn/item/60289d32d2a061fec7b57bf2.png)

如图所示

[![](https://pic.imgdb.cn/item/60a5fb4f6ae4f77d35e55728.jpg)](https://pic.imgdb.cn/item/60a5fb4f6ae4f77d35e55728.jpg)

主内存有一个变量为x = 1，线程1和线程2都读取了他，这时线程1修改了x，那么线程2是否可以得知呢？

我们来写一段代码测试一下

```java
public class Test {
    static int x = 1;

    public static void main(String[] args) throws InterruptedException {
        new Thread(()->{
            while (x == 1){

            }
        },"A").start();

        TimeUnit.SECONDS.sleep(2);

        x = 2;

   
    }
}
```

我们测试，这个程序不会停止，这就是说线程A不知道变量被修改了。

**我们的可见性是面临两个大问题的：**

1. **线程1在修改变量后不能在第一时间内变量不会刷回主内存。**
2. **线程2不知道变量已经被修改。**

第一个问题还算比较好解决，我们每次修改变量之后，第一时间刷回主内存。

第二个问题就比较棘手了，难道我们每次都得重新去主内存中拿吗？

有些小伙伴想说，可以呀，这不就很容易就解决了吗？

其实不然，JMM只是java官方为了便于我们理解而提出的一个抽象的概念，实际上JMM的实现与硬件息息相关，大概长这个样子：

[![](https://pic.imgdb.cn/item/60a600ff6ae4f77d35114d90.jpg)](https://pic.imgdb.cn/item/60a600ff6ae4f77d35114d90.jpg)

如果我们每次都去放弃缓存中的数据，而重新从内存中读取，那么在年对这种情况时缓存不仅无益，反而会拖慢速度，但是呢，我们是站在巨人的肩膀上的，很明显这根总线可以帮我们做很多事情

1. #### 总线锁

   在早期的处理器会提供一个LOCK信号，在CPU1操作共享变量时会对总线进行加锁，此时CPU2就不能再读取内存中的数据了，这会大大降低CPU的执行效率。

2. #### 缓存一致性协议

   为解决这种问题，Intel推出了MESI协议，可以保证各线程的共享变量的副本都是一致的。

3. #### MESI的思想

   modified（修改）、exclusive（互斥）、share（共享）、invalid（无效）

   CPU1使用共享数据时会先数据拷贝到CPU1缓存中,然后置为独占状态(E)，这时CPU2也使用了共享数据，也会拷贝也到CPU2缓存中。通过总线嗅探机制，当该CPU1监听总线中其他CPU对内存进行操作，此时共享变量在CPU1和CPU2两个缓存中的状态会被标记为共享状态(S)；

   若CPU1将变量通过缓存回写到主存中，需要先锁住缓存行，此时状态切换为（M），向总线发消息告诉其他在嗅探的CPU该变量已经被CPU1改变并回写到主存中。接收到消息的其他CPU会将共享变量状态从（S）改成无效状态（I），缓存行失效。若其他CPU需要再次操作共享变量则需要重新从内存读取。

4. #### 嗅探机制

   每个处理器会通过嗅探器来监控总线上的数据来检查自己缓存内的数据是否过期，如果发现自己缓存行对应的地址被修改了，就会将此缓存行置为无效。当处理器对此数据进行操作时，就会重新从主内存中读取数据到缓存行。

好了，到这里大家应该明白了我们的计算机是如何解决可见性问题的。

优点：我们不需要去频繁的从内存中获取最新的值，只需要使用嗅探机制去监听就好了

缺点：一种技术必定会有它负面的一面，如果大量的使用volatile关键字，那么就很有可能产生总线风暴

CAS同理，在多个CPU执行同一个CAS操作时，势必要保证可见性，因此也会出现总线风暴问题。