# 运行时数据区概述（三）

终于咱们的运行时数据区要结束了，咱们就来看看最后一个数据区——**方法区**。

### 方法区概述

首先我们先看看[官方文档](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4)

《Java虚拟机规范》中说道“尽管所有的方法区在逻辑上属于堆，但是一些简单的实现可能不会选择去进行垃圾收集或者压缩”对于HotSpotJVM而言，方法区有一个别名叫Non-Heap（非堆），目的是为了与堆分开。

**因此，方法区可看作一块独立于堆的内存空间。**

- 方法区与堆一样，线程共享。
- 方法区在jvm启动时创建，并且他的实际内存空间与堆一样可不连续。
- 方法区大小与堆一样，可选择固定大小或者可拓展。
- 方法区的大小决定了系统可保存多少个类，会溢出，会报OOM：PermGen space (JDK7及以前) / Metaspace（JDK8及以后）

### 方法区的演变

首先，在jdk7及以前，方法区的落地实现为永久代，8之后变为元空间。



|        | 默认初始大小 |      默认最大大小       |                           存储内容                           |
| :----: | :----------: | :---------------------: | :----------------------------------------------------------: |
| 永久代 |    20.75M    | 32位机器64M/64位机器82M | 类型信息<br />运行时常量池<br />域信息<br />方法信息<br />JIT代码缓存<br />静态变量（jdk6及以前，jdk7时移到堆了） |
| 元空间 |     21M      |     -1（即无限制）      | 类型信息<br />运行时常量池<br />域信息<br />方法信息<br />JIT代码缓存 |

详细概念：

- 类型信息：类的修饰符等
- 运行时常量池：为节省内存，会把常量放进常量池（可看作一张表）
- 域信息：属性
- 方法信息：方法
- 静态变量：类变量

> 常量池表与运行时常量池
>
> 常量池表：是class文件的一部分，在类加载之后存放到运行时常量池中
>
> 运行时常量池：具备动态性

再详细说说演变过程

jdk1.6及之前：有永久代，静态变量保存在永久代。

jdk1.7：有永久代，但是oracle去永久代，将字符串常量池和静态变量移除，保存在堆。

jdk8及以后：无永久代，取而代之元空间。

![](https://pic.imgdb.cn/item/60181fbe3ffa7d37b3097cfd.png)

![](https://pic.imgdb.cn/item/60181fcf3ffa7d37b3098517.png)

![](https://pic.imgdb.cn/item/60181fef3ffa7d37b30992d0.png)

**关于永久代为什么会被替换？**

官方解释：[任性！](http://openjdk.java.net/jeps/122)

实际上：

1. 对永久代设置空间大小很难，大了怕浪费，小了就会OOM
2. 对永久代调优比较困难。

**那字符串常量池为什么会移动？**

因为往往有很多字符串被创建，在方法区的话回收率会很低。因此为了降低gc时的代价，就移入堆中。

### 方法区的垃圾回收

1. **回收内容：**

   - 常量池中废弃的常量
   - 不再使用的类型

2. **回收条件**

   1. 常量：和堆中的对象很相似，只要常量池中的常量没有被任何地方所引用，就可以被回收。

   2. 类型：很复杂

      ![](https://pic.imgdb.cn/item/601822423ffa7d37b30a8733.png)