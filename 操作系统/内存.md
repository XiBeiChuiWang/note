### 内存基础

**计算机的基本设计思想是取指执行，基本过程为：**

1.  **编译：**由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言） 

2.  **链接：**由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块 

   **链接的3种方法：**

   1.  **静态链接：**在程序运行之前， 先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。 
   2.  **装入时动态链接：**将各目标模块装入内存时，边装入边链接的链接方式。  
   3.  **运行时动态链接：**在程序执 行中需要该目标模块时，才 对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。 

3.  **装入（装载）：**由装入程序将装入模块装入内存运行 

   **装入的3种方法：**

   1.  **绝对装入：**在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。 装入程序按照装入模块中的地址，将程序和数据装入内存。  绝对装入只适用于单道程序环境 。
   2.  **静态重定位：**又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地 址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入 时一次完成的）。 
   3.  **动态重定位：**又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装 入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行 时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。 

   ### 内存管理

   1. ####  内存空间的分配与回收 

      **概念**： 操作系统要怎么记录哪些内存区域已经被分配出去了， 哪些又还空闲？ 

      ​             当进程运行结束之 后，如何将进程占 用的内存空间回收？ 

      1. #####  连续分配管理方式 

         1. **单一连续分配**

            在单一连续分配方式中，内存被分为系统区和用户区。 系统区通常位于内存的低地址部分，用于存放操作系统 相关数据；用户区用于存放用户进程相关数据。 内存中只能有一道用户程序，用户程序独占整个用户区空间。  

            **缺点：**只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。 

         2.  **固定分区分配** 

            分区大小相等，缺乏灵活性，但是很适合用于用一台计 算机控制多个相同对象的场合 

             操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。 

             **缺点：**

            当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采 用覆盖技术来解决，但这又会降低性能；

            会产生内部碎片，内存利用率低。 

         3.  **动态分区分配** 

            动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时， 根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数 目是可变的。 

             把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。 

            **动态分区分配算法**：

            1.  **首次适应算法** 

                **算法思想：**每次都从低地址开始查找，找到第一个能满足大小的空闲分区。 

                **如何实现：**空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区 表），找到大小能满足要求的第一个空闲分区。 

            2.  **最佳适应算法** 

                **算法思想：**由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区 域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区， 即，优先使用更小的空闲区。 

                **如何实现：**空闲分区按容量**递增次序**链接。每次分配内存时顺序查找空闲分区链（或空闲分区 表），**找到大小能满足要求的第一个空闲分区**。 

                **缺点：**每次都选最小的分区进行分配，会留下越来越多的、很小 的、难以利用的内存块。因此这种方法会产生很多的外部碎片。 

            3.  **最坏适应算法** 

               又称**最大适应算法** 

               **算法思想：**为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时 优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。
               **如何实现：**空闲分区按容量**递减次序**链接。每次分配内存时顺序查找空闲分区链（或空闲分区 表），**找到大小能满足要求的第一个空闲分区**。 

               **缺点：**每次都选最大的分区进行分配，虽然可以让分配后留下的 空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被 迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。 

            4.  **邻近适应算法** 

               **算法思想：**首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲 分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查 找结束的位置开始检索，就能解决上述问题。 

               **如何实现：**空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。 

            ![](https://pic.downk.cc/item/5fe5f2483ffa7d37b3032dcc.png)

      2. ##### 非连续分配管理方式

         1. **基本分页式**

             将内存空间分为一个个大小相等的分区（比如：每个分区 4KB），每个分区就是一个“页框”（页框=页帧=内存块=物理 块=物理页面）。每个页框有一个编号，即“页框号”（页框 号=页帧号=内存块号=物理块号=物理页号），页框号从0开始。 

             将进程的逻辑地址空间也分为与**页框大小相等**的一个个部分， 每个部分称为一个“页”或“页面” 。每个页面也有一个编号， 即“页号”，页号也是从0开始。 

             **重要的数据结构——页表** 

            ![](https://pic.downk.cc/item/5fe5f3a93ffa7d37b3057a8a.png)

            **具有快表的地址变换机构** 

            ![](https://pic.downk.cc/item/5fe5f4433ffa7d37b30676ac.png)

             例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访 问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？

             (1+100) *	0.9 + (1+100+100) *	0.1 = 111 us 有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是 (1+100) *	0.9 + (100+100) *0.1 = 110.9 us 

            若未采用快表b机制，则访问一个逻辑地址需要 100+100 = 200us 

             **单级页表存在的问题** 

             **问题一：**页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。

             **问题二：**没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。 

            **因此使用多级页表**

         2. **基本分段式**

             **进程的地址空间：**按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言 中，程序员使用段名来编程），每段从0开始编址内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。 

            **段号的位数决定了每个进程最多可以分几个段** 

            **段内地址位数决定了每个段的最大长度是多少** 

            ![](https://pic.downk.cc/item/5fe5f60c3ffa7d37b3099d33.png)

            ![](https://pic.downk.cc/item/5fe5f6e13ffa7d37b30af632.png)

             **分段、分页管理的对比** 

             **页是信息的物理单位。**分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管 理上的需要，完全是系统行为，**对用户是不可见的。** 

            **段是信息的逻辑单位。**分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻 辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。 

            **分页的用户进程地址空间是一维的**，程序员只需给出一个记忆符即可表示一个地址。 

            **分段的用户进程地址空间是二维的**，程序员在标识一个地址时，既要给出段名，也要给出段内地址。 

            ![](https://pic.downk.cc/item/5fe5f7903ffa7d37b30c2756.png)

         3. **段页式**

            ![](https://pic.downk.cc/item/5fe5f8323ffa7d37b30d4c30.png)

            

         4. 

   2. ####  内存空间的扩展 

      **概念：** 操作系统的虚拟性 

      1. **覆盖技术**

         **覆盖技术的思想：**将程序分为多个段（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。 

         内存中分为一个“固定区”和若干个“覆盖区”。  

         需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束） 

         不常用的段放在“覆盖区”，需要用到时调入内存， 用不到时调出内存 

         ![](https://pic.downk.cc/item/5fe5eea03ffa7d37b3fce0c2.png)

      2. **交换技术**

         **交换（对换）技术的设计思想：**内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中 某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）  

         1. 具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件 区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采 用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放 在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理 主要追求换入换出速度，因此通常对换区采用连续分配方式（学过文件管理章节 后即可理解）。总之，对换区的I/O速度比文件区的更快。 

         2. 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程； 如果缺页率明显下降，就可以暂停换出。 

         3. 可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调 入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间… 

            **置换算法**

            ![](https://pic.downk.cc/item/5fe5fa323ffa7d37b310c418.png)

             **页面分配策略** 

             **固定分配：**操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集 大小不变 

            **可变分配：**先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。 即，驻留集大小可变 

            **局部置换：**发生缺页时只能选进程自己的物理块进行置换。 

            **全局置换：**可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换 到外存，再分配给缺页进程。 

            **固定分配局部置换：**系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运 行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略 的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可 以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数） 

            **可变分配全局置换：**刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一 个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页， 都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页 可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。 

            **可变分配局部置换：**刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配 几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减 少分配给该进程的物理块。 

            1. **系统拥有足够的对换区空间：**页面的调入、调 出都是在内存与对换区之间进行，这样可以保 证页面的调入、调出速度很快。在进程运行前， 需将进程相关的数据从文件区复制到对换区。
            2. **系统缺少足够的对换区空间：**凡是不会被修改 的数据都直接从文件区调入，由于这些页面不 会被修改，因此换出时不必写回磁盘，下次需 要时再从文件区调入即可。对于可能被修改的 部分，换出时需写回磁盘对换区，下次需要时 再从对换区调入。 
            3. **UNIX 方式：**运行之前进程有关的数据全部放在 文件区，故未使用过的页面，都可从文件区调 入。若被使用过的页面需要换出，则写回对换 区，下次需要时从对换区调入。 

      3. **虚拟存储**

          **多次性：**无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。 

         **对换性：**在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换 入、换出。 

         **虚拟性：**从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。 

         **虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此， 虚拟内存的实现需要建立在离散分配的内存管理方式基础上。** 

   3. ####  地址转换 

      

   4. ####  内存保护 

   

 